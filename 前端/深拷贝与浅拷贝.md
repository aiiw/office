| 深拷贝                                                       | 浅拷贝                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| JSON.parse(JSON.stringify(obj))：使用JSON.stringify()将对象序列化为JSON字符串，再使用JSON.parse()解析该字符串并返回一个新的JavaScript对象。这种方法可以对大多数JavaScript对象进行深度拷贝，但不支持函数、Symbol类型和循环引用的对象。 | Object.assign()方法：创建一个新对象并将原始对象的属性复制到新对象中。如果属性值是对象或数组，则只会复制它们的引用而不是它们的内容。 |
| 递归实现深度拷贝：遍历对象的每个属性，如果属性的值是对象或数组，则递归调用自己，直到所有嵌套的对象都被复制。 | 数组的slice()方法或展开运算符 ...：使用数组的slice()方法或展开运算符 ... 创建新的浅层副本。如果属性值是对象或数组，则只会复制它们的引用而不是它们的内容。 |
| Lodash等第三方库中提供的深拷贝函数（如_.cloneDeep()）：使用Lodash等第三方库中提供的函数来完成深拷贝操作。这些函数通常可以处理各种特殊情况，如循环引用、Date对象、RegExp对象等。 | 手动遍历对象并复制每个属性的值：手动遍历对象的每个属性，然后将其复制到新对象中。如果属性值是对象或数组，则只会复制它们的引用而不是它们的内容。 |



| 深拷贝方法                                    | 浅拷贝方法                                            |
| --------------------------------------------- | ----------------------------------------------------- |
| 使用`JSON.parse(JSON.stringify(obj))`方法     | 使用扩展运算符`...`或`Object.assign()`方法            |
| 使用第三方库如`lodash`中的`_.cloneDeep()`方法 | 直接使用赋值操作`=`                                   |
| 自实现递归函数进行深拷贝                      | 使用`Array.prototype.slice()`方法进行浅拷贝数组       |
| 使用`MessageChannel`构造函数进行深拷贝        | 使用`Array.prototype.concat()`方法进行浅拷贝数组      |
| 使用`Structured Clone Algorithm`进行深拷贝    | 使用ES6中的扩展运算符进行浅拷贝数组、对象和类数组对象 |

示例：

```
虽然slice()和concat()方法返回的是一个新数组，但它们所创建的新数组中包含的元素与原始数组中的元素仍然是相同的引用。这意味着如果原始数组中的一个元素是对象或数组，那么在新数组中对该元素所做的更改将会影响到原始数组中的该元素。因此，这种复制方式称为浅拷贝。
```



```
javascript复制代码// 深拷贝示例：
const obj = {
  a: 1,
  b: {
    c: 2
  }
};

const newObj = JSON.parse(JSON.stringify(obj));
newObj.b.c = 3;

console.log(obj); // {a: 1, b: {c: 2}}
console.log(newObj); // {a: 1, b: {c: 3}}

// 浅拷贝示例：
const arr = [1, 2, 3];
const newArr = arr.slice();
newArr[0] = 10;

console.log(arr); // [1, 2, 3]
console.log(newArr); // [10, 2, 3]
```
【实习之T100开发】T100 双档程序开发流程

萌宅鹿同学

于 2021-01-29 15:08:10 发布

3804
 收藏 30
分类专栏： T100开发 文章标签： Tiptop 4gl
版权

T100开发
专栏收录该内容
13 篇文章92 订阅
订阅专栏
T100双档程序开发
单双档程序的 (全新) 开发流程
r.t 建表
1. 建立单头表
2. 建立单身表
3. 单身表 中建立主外键关联
4. 建表完成执行操作
双档 (全新) 完整开发
r.t 建表
1. azzi900 建立 程序编号
2. azzi910 建立 作业编号
3. 设计器 - 签出规格和程序
【4】 adzp168画面产生器（产生画面）???
6. 设计器 - 规格（下载规格）
7. 设计器 - 档案 - 开启档案（修改规格）
【8】r.q 开窗，r.v 校验带值（根据需求设定）???
表头开窗、校验带值、设置参考字段
表身开窗、校验带值、设置参考字段
9. 设计器 - 程序（下载程序）
【10】 设计器 - 档案 - 开启档案，直接上传程序（修改程序）
单头部分
新增开窗①单号开窗需要传参数（参照表编号、程序编号）+ 开窗测试工具使用
新增开窗①++ 将开窗要传的参数改为全局变量
新增开窗②将单据日期默认为今天
新增开窗③开窗传参（交易条件）
校验带值 - 单据别
根据 [税种] 带出 [含税否]
根据 [币种] 带出 [汇率]
查询开窗
查询开窗 - 单号（自建开窗）
单身部分
项次自增
表身根据[料号]带出[品名]和[规格]
单身根据 [税种] 带出 [税率]
[数量]、[单价] 变化时要计算[含税金额]、[未税金额]、[税额]
查询时单身部分[规格]不显示（新增时有的）
12. azzi850 给程序授权
13. r.r 执行程序
14. azzi880 将程序挂到 menu
单据别建立流程 ???
双档程序源码分析
总结
目录：【实习】T100学习笔记

单档程序和双档程序的区别
所谓单档程序相当于只有表头，下面的东西就相当于表头。

而双档不仅有表头，还有表身，表身一般就是个表格。


单双档程序的 (全新) 开发流程
首先要通过 r.t (adzi140) 建立表

azzi900 建立 程序代号
程序代号是唯一的。
azzi910 建立 作业代号
一个程序代号可以被多个作业使用。
通过设计器 - 规格（签出规格）
规格相当于画面。
通过设计器 - 程序（签出程序）
adzp168 通过画面产生器产生画面
通过设计器 - 规格（下载规格）
r.q 开窗，r.v 校验带值（根据需求设定）
通过设计器 - 程序（下载程序）
通过设计器 - 档案（开启规格档案）- 修改程序 - 上传程序
通过设计器 - 程序（下载程序）- 上传程序
（先上传程序，没有报错再来修改对应逻辑）
通过 azzi850 给程序授权
r.r 执行程序
azzi880 将程序挂到 menu
r.t 建表
单头表 xmzyuc_t，字段为：订单单号、订单日期、业务人员、业务部门、客户编号、收款条件、交易条件、税种、币种、税率、含税否、汇率、发票类型、订单备注、基础资料档。

单身表 xmzzuc_t，字段为：项次、料号 (品名、规格)、单位 (单位名称)、订购数量、预计交货日期、税种、税率、单位、含税金额、未税金额、税额、紧急度、备注

单档程序只需要一张表，双档需要建多张表。

1. 建立单头表
单头一般是主档

企业代码、营运据点基本是必要的，其他按需求设置。

字段设置完毕后，【执行异动】

2. 建立单身表
单身一般是明细档


单身表与单头表的主键位置需要一一对应，不然自动生成的SQL语句会关联错误。
单头表的顺序是：企业代码(主)、营运据点、单号(主)、…
则单身表的顺序必须是：企业代码(主)、营运据点、单号(主)、…

单身表一定会比单头表多1个主键。

字段设置完毕后，【执行异动】

3. 单身表 中建立主外键关联
在单身表中建立与单头表的主外键关联。


同时查出多张表的小技巧：xmzyuc | xmzzuc


4. 建表完成执行操作
所有步骤完成后按照如下顺序操作：

单头【产出数据表纲要】、单身【产出数据表纲要】、
单头【产出数据表清单】、单身【产出数据表清单】
单头【产出数据表结构与规格设置】、单身【产出数据表结构与规格设置】
双档 (全新) 完整开发
注：双档和单档在整体流程上差不多，所以这里过程很简略，具体有哪个步骤忘记可以参考单档的文章（图片很全，很细）。

T100 单档程序开发（1）开发流程

r.t 建表
adzi170 可以查询数据表的内容

1. azzi900 建立 程序编号
点击【录入信息】，然后输入 [程序编号] 和 [程序名称]，选择 [归属模块]


2. azzi910 建立 作业编号
由于是订单维护作业，还需要建立单据别，具体参考下面的单据别建立流程

3. 设计器 - 签出规格和程序
【4】 adzp168画面产生器（产生画面）???

点击【字段设置】，分别给单头、单身以及查询方案设置字段

单头设置字段，注意 Table 必须选中单头表，画面结构要选中 Page:page_1


ps：上图少放了一个字段单据日期。。已补上，截图没有改

单身设置字段，Table 选中单身表，画面结构中选中 Table:s_detail1。单号是单头和单身的主键，单头里放了，单身不需要再放。

查询方案设置字段，查询方案一般放一些重要的单头字段

操作完以后，【保存底稿】、【生成画面】，弹出预览界面后关掉它。

6. 设计器 - 规格（下载规格）
7. 设计器 - 档案 - 开启档案（修改规格）
如果没有数据，【进阶功能】-【更新基础数据】、【重新产生基础数据】

注意，带开窗的组件有的需要自己转：右键，Concert Widget，ButtonEdit 即可。

【8】r.q 开窗，r.v 校验带值（根据需求设定）???
业务人员开窗 可以抄 资料所有者开窗
业务部门开窗 可以抄 资料所有部门开窗
所有的都可以抄 axmt500。。。。

表头开窗、校验带值、设置参考字段
业务人员开窗

业务人员参考语系


交易条件开窗

交易条件参考字段 ******************

太多了。。直接抄 axmt500 。。。。。

表身开窗、校验带值、设置参考字段
开窗抄 axmt500，参考字段需要点击要添加的列，右键 Add Reference Field，然后抄 axmt500

9. 设计器 - 程序（下载程序）
【10】 设计器 - 档案 - 开启档案，直接上传程序（修改程序）
将刚下载的程序直接【上传】一下，确保设计器默认生成的没有问题，再开始修改。

单头部分
新增开窗①单号开窗需要传参数（参照表编号、程序编号）+ 开窗测试工具使用
下图中，在 adzi210开窗设计器中可以看到，单号的开窗识别码要求传2个参数，分别是 参照表编号 和 程序编号 ，需要我们在代码里添加。

参照表编号 在下面的【单据别建立流程】中有讲，aooi100 中可以查看
程序编号在代码里是个全局变量，g_prog，本程序中即 cxmt666



如何知道对应的数据表字段？
在 aooi100 中查询过后，可知参照表编号为 S01
并且，我们将鼠标放上去，可以看见它是在哪个数据库中进行维护的。

查看 ooef_t 表，发现 ooef004 的确是参照表编号。


开窗测试工具的使用
在 adzi210开窗设计工具中，查出了对应的开窗识别码后，点击【开窗测试工具】，然后将对应的参数输入，点击右边的开窗，即可查出对应的值。

如果没有查出来，按照【单据别建立流程】检查一遍流程。



在 ON ACTION controlp INFIELD xmzyucdocno，即点击单号开窗的位置，写代码：

#add by lzy #2021/1/27 根据当前的据点找到对应的单据别参照表号
LET l_ooef004 = ''
SELECT ooef004 INTO l_ooef004 FROM ooef_t
WHERE ooefent = g_enterprise #企业编号=当前企业编号
AND ooef001 = g_site #组织编号=据点 

#給予arg
LET g_qryparam.arg1 = l_ooef004
LET g_qryparam.arg2 = g_prog #程序编号:cxmt666
1
2
3
4
5
6
7
8
9
注：l_ooef004 需要在前面定义变量，我们在 cxmt666_input() 开头定义：

DEFINE l_ooef004 LIKE ooef_t.ooef004 #add by lzy#2021/1/27 单据别参照表号
1
学会这个以后，再有开窗需要传参的，都是以此类推！

新增开窗①++ 将开窗要传的参数改为全局变量
在 ① 里我们是用 l_ 开头的局部变量的方式写的，但是有时候很多开窗要传的参数是一样的，如果每次都要重新写，那将很麻烦，不如直接改成全局变量，后需要用到都可以拿来用。

将变量声明到 MAIN 上面的全局区域：

#add-point:自定義模組變數(Module Variable) (請盡量不要在客製環境修改此段落內容, 否則將後續patch的調整需人工處理) name="global.variable"
DEFINE  g_ooef004 LIKE ooef_t.ooef004 #add by lzy#2021/1/27 单据别参照表号
DEFINE  g_ooef024 LIKE ooef_t.ooef024 #add by lzy#2021/1/27 供应商编号
DEFINE  g_ooef019 LIKE ooef_t.ooef019 #add by lzy#2021/1/27 税区编号
#end add-point
1
2
3
4
5
在 xxxx_init() 的画面资料初始化区域写SQL查询：

#add-point:畫面資料初始化 name="init.init"
LET g_ooef004 = ''
LET g_ooef024 = ''
SELECT ooef004,ooef024,ooef019 INTO g_ooef004,g_ooef024,g_ooef019 FROM ooef_t
WHERE ooefent = g_enterprise #企业编号=当前企业编号
AND ooef001 = g_site #组织编号=据点 
#end add-point
1
2
3
4
5
6
7
最后在 ON ACTION controlp INFIELD xxxxx 处给参数赋值即可。

新增开窗②将单据日期默认为今天
在 xxx_insert() 中的单头预设值处填写代码：

#add-point:單頭預設值 name="insert.default"
LET g_xmzyuc_m.xmzyucdocdt = g_today #add by lzy#2021/1/27 单据日期默认为今天
#end add-point
1
2
3
新增开窗③开窗传参（交易条件）
交易条件由 apmi012 维护。

直接在代码里给传入参数设为 '238' 即可。

LET g_qryparam.arg1 = '238' #交易条件
1
校验带值 - 单据别
校验带值都是写在 xxxx_input() 下的 AFTER FIELD xxxxx。

比如要写单号 xmzyucdocno 的校验带值，写下面代码：

#add by lzy 单据别校验带值
IF NOT s_aooi200_chk_slip(g_site,'',g_xmzyuc_m.xmzyucdocno,g_prog) THEN
   LET g_xmzyuc_m.xmzyucdocno = g_xmzyucdocno_t	
   NEXT FIELD CURRENT   
END IF
1
2
3
4
5
客户编号校验带值，直接抄 axmt500，参数也要一起抄。。

#設定g_chkparam.*的參數
LET g_chkparam.arg1 = g_xmzyuc_m.xmzyuc003
LET g_chkparam.arg2 = g_site 
#呼叫檢查存在並帶值的library
IF cl_chk_exist("v_pmaa001_3") THEN
   #檢查成功時後續處理
ELSE
   #檢查失敗時後續處理
   NEXT FIELD CURRENT
END IF
1
2
3
4
5
6
7
8
9
10
后面有问题的校验带值，都直接抄。。。

根据 [税种] 带出 [含税否]

要达到的效果主要是选择了 [税种] 以后，下面的 [税率] 和 [含税否] 也会自动有值。

现在开始不用记那么多套路了，抄axmt500就完事，上传报错就跟着报错信息改，比如下面的代码直接上传会报错，因为 l_success 和 l_oodb011 都没有定义，去axmt500里搜一下，看看它怎么定义的，直接拿过来来。

顺带一提，视频中老师一开始都是自己写的，讲道理真的看不懂，直到后面她开始抄axtm500。。。我也就学会了抄了。。

AFTER FIELD xmzyuc006

   #add-point:AFTER FIELD xmzyuc006 name="input.a.xmzyuc006"
   LET g_xmzyuc_m.xmzyuc006_desc = ''
   IF NOT cl_null(g_xmzyuc_m.xmzyuc006) THEN 
      IF p_cmd = 'a' OR (p_cmd = 'u' AND (g_xmzyuc_m.xmzyuc006 <> g_xmzyuc_m_o.xmzyuc006 OR g_xmzyuc_m_o.xmzyuc006 IS NULL)) THEN              
         CALL s_tax_chk(g_site,g_xmzyuc_m.xmzyuc006)
           RETURNING l_success,g_xmzyuc_m.xmzyuc006_desc,g_xmzyuc_m.xmzyuc009,g_xmzyuc_m.xmzyuc008,l_oodb011                         
         IF NOT l_success THEN
            LET g_xmzyuc_m.xmzyuc006 = g_xmzyuc_m_o.xmzyuc006
            LET g_xmzyuc_m.xmzyuc008 =  g_xmzyuc_m_o.xmzyuc008
            LET g_xmzyuc_m.xmzyuc009 =  g_xmzyuc_m_o.xmzyuc009
            NEXT FIELD CURRENT                     
         ELSE                    
            #pass
         END IF                       
      END IF
      LET g_xmzyuc_m_o.xmzyuc006 = g_xmzyuc_m.xmzyuc006
      LET g_xmzyuc_m_o.xmzyuc008 = g_xmzyuc_m.xmzyuc008
      LET g_xmzyuc_m_o.xmzyuc009 = g_xmzyuc_m.xmzyuc009
   END IF 
              
   CALL s_desc_get_tax_desc1(g_site,g_xmzyuc_m.xmzyuc006) RETURNING g_xmzyuc_m.xmzyuc006_desc
   DISPLAY BY NAME g_xmzyuc_m.xmzyuc006,g_xmzyuc_m.xmzyuc008,g_xmzyuc_m.xmzyuc009,g_xmzyuc_m.xmzyuc006_desc 

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
根据 [币种] 带出 [汇率]
这个有坑！直接抄 axmt500也可能会跳进坑里。。。主要在于它似乎需要一个 [内外销] 字段来计算出汇率。。。但是这个字段在我的项目中并没有建，我只能在调函数s_axmt540_get_exchange的时候手动给这个参数传值，经过测试，只要传'2'就可以了。

#應用 a02 樣板自動產生(Version:2)
AFTER FIELD xmzyuc007

  LET g_xmzyuc_m.xmzyuc007_desc = ''
   IF NOT cl_null(g_xmzyuc_m.xmzyuc007) THEN 
      IF p_cmd = 'a' OR (p_cmd = 'u' AND (g_xmzyuc_m.xmzyuc007 != g_xmzyuc_m_o.xmzyuc007 OR g_xmzyuc_m.xmzyuc010 IS NULL )) THEN   
         IF cxmt666_xmzyuc007_chk(g_xmzyuc_m.xmzyuc007) THEN
         	   #########这里的参数 '2' 是我手动传的，我的项目中没有[内外销]字段
               CALL s_axmt540_get_exchange('2',g_xmzyuc_m.xmzyuc007,g_xmzyuc_m.xmzyucdocdt) RETURNING g_xmzyuc_m.xmzyuc010   #modify--151118-00012#1 By shiun   新增傳入參數g_xmda_m.xmdadocdt
               LET g_xmzyuc_m_o.xmzyuc010 = g_xmzyuc_m.xmzyuc010
               DISPLAY BY NAME g_xmzyuc_m.xmzyuc010
         ELSE
            #檢查失敗時後續處理
            LET g_xmzyuc_m.xmzyuc007 = g_xmzyuc_m_t.xmzyuc007
            NEXT FIELD CURRENT
         END IF 

         #匯率取位
         IF NOT cl_null(g_xmzyuc_m.xmzyuc010) THEN
            CALL s_curr_round(g_site, g_xmzyuc_m.xmzyuc007,g_xmzyuc_m.xmzyuc010,'3') RETURNING g_xmzyuc_m.xmzyuc010
         END IF
         #160711-00010#1-add-(E)                  
      END IF             
   END IF
   #170326-00004#3 by sakura add(S)
   CALL cxmt666_set_entry(p_cmd)
   CALL cxmt666_set_no_entry(p_cmd)
   #170326-00004#3 by sakura add(E)                        
   CALL s_desc_get_currency_desc(g_xmzyuc_m.xmzyuc007) RETURNING g_xmzyuc_m.xmzyuc007_desc 
   DISPLAY BY NAME g_xmzyuc_m.xmzyuc007_desc
   LET g_xmzyuc_m_o.xmzyuc007 = g_xmzyuc_m.xmzyuc007           

   #END add-point

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
查询开窗
单头的查询在 xxxx_construct 下 CONSTRUCT BY NAME g_wc 里的 ON ACTION...

其他操作和【新增开窗】大体一样，T100生成的基本都是要求传参数的没有传或者传的不对，我们将参数写对就可以了。

如果【编辑时开窗】与【查询时开窗】设置的是一样的话，完全可以去把之前写好的编辑时开窗的内容拿过来就可以了。

查询开窗 - 单号（自建开窗）
自建步骤就是，随便复制一笔简单的，输入名字 cq_xxxxx，然后查询这笔再去修改它，修改成如下图，即可在代码里直接呼叫该开窗了。

呼叫开窗的操作如下：

ON ACTION controlp INFIELD xmzyucdocno
   #add-point:ON ACTION controlp INFIELD xmzyucdocno name="construct.c.xmzyucdocno"
   #查询时开窗 add by lzy

   INITIALIZE g_qryparam.* TO NULL
   LET g_qryparam.state = 'c' 
   LET g_qryparam.reqry = FALSE

   CALL q_ooba002_1()                           #呼叫開窗
   DISPLAY g_qryparam.return1 TO xmzyucdocno  #顯示到畫面上
   NEXT FIELD xmzyucdocno                     #返回原欄位

   #END add-point
1
2
3
4
5
6
7
8
9
10
11
12
13
单身部分
项次自增
在 axmt500 xxxx_input > DIALOG > BEFORE INSERT 下的 #項次加1 处可以捞到代码；

然后放到自己项目中：

#add-point:modify段before備份 name="input.body.insert.before_bak"
#项次加一 add by lzy 2021/1/28
SELECT MAX(xmzzucseq)+1 INTO g_xmzzuc_d[l_ac].xmzzucseq FROM xmzzuc_t
 WHERE xmzzucent = g_enterprise AND xmzzucdocno = g_xmzyuc_m.xmzyucdocno
IF cl_null(g_xmzzuc_d[l_ac].xmzzucseq) OR g_xmzzuc_d[l_ac].xmzzucseq = 0 THEN
   LET g_xmzzuc_d[l_ac].xmzzucseq = 1
END IF
#end add-point
1
2
3
4
5
6
7
8
表身根据[料号]带出[品名]和[规格]
在 ON ACTION controlp INFIELD xmzzuc001 处，主要的坑就是把原本的注释取消后要改成自己项目中的名字。。


例如下图是我的[品名]控件名称：


单身根据 [税种] 带出 [税率]
主要就是去 单身中税种字段对应的 AFTER FIELD xxxx，首先将 校验带值的参数写正确；
然后可以在后面直接加上这个：

#带出税率的值 add by lzy
CALL s_tax_chk(g_site,g_xmzzuc_d[l_ac].xmzzuc005)
  #注意：l_xmzyuc005_desc,l_hanshuifou是自定义的，需要这么多参数来接收函数的返回值
  RETURNING l_success,l_xmzyuc005_desc,l_hanshuifou,g_xmzzuc_d[l_ac].xmzzuc006,l_oodb011                         
IF NOT l_success THEN
   #pass
ELSE                    
   #pass
END IF    
1
2
3
4
5
6
7
8
9
但是要注意，l_xmzyuc005、l_hanshuifou 需要我们自己定义，在input开头定义：

DEFINE  l_xmzyuc005_desc      LIKE type_t.chr100
DEFINE  l_hanshuifou          LIKE type_t.chr1
1
2


[数量]、[单价] 变化时要计算[含税金额]、[未税金额]、[税额]
了解一下这个函数 s_axmt500_get_amount_2

在azzq171中可进行查询

注意，当 [数量] 和 [单价] 都不为空的时候，才会去计算，所以要先判断非空。
然后当 [数量] 和 [单价] 改变后都会出发计算，所以要把下面的代码放在 [数量] 和 [单价]的 AFTER FIELD 部分。

#add-point:AFTER FIELD xmzzuc007 name="input.a.page1.xmzzuc007"
#当[数量]和[单价]都不为空的时候,才会去计算 add by lzy
IF NOT cl_null(g_xmzzuc_d[l_ac].xmzzuc007) AND NOT cl_null(g_xmzzuc_d[l_ac].xmzzuc003) THEN
   # s_axmt500_get_amount_2 是个公共函数,用来计算 未税金额、含税金额、税额
   CALL s_axmt500_get_amount_2(g_xmzzuc_d[l_ac].xmzzuc003,g_xmzzuc_d[l_ac].xmzzuc007,g_xmzzuc_d[l_ac].xmzzuc005,g_xmzyuc_m.xmzyuc007,g_xmzyuc_m.xmzyuc010)
      RETURNING g_xmzzuc_d[l_ac].xmzzuc009,g_xmzzuc_d[l_ac].xmzzuc008,g_xmzzuc_d[l_ac].xmzzuc010
END IF
DISPLAY BY NAME g_xmzzuc_d[l_ac].xmzzuc009,g_xmzzuc_d[l_ac].xmzzuc008,g_xmzzuc_d[l_ac].xmzzuc010 #显示到界面上
#END add-point
1
2
3
4
5
6
7
8
9
有的时候单身的数据要和单头数据保持一致，我们在BEFORE INSERT中可设置初始值。

#让单身的[税种]和单头的[税种]保持一致 add by lzy
LET g_xmzzuc_d[l_ac].xmzzuc005 = g_xmzyuc_m.xmzyuc006
#让单身的[税率]和单头的[税率]保持一致 add by lzy
LET g_xmzzuc_d[l_ac].xmzzuc006 = g_xmzyuc_m.xmzyuc008
1
2
3
4
查询时单身部分[规格]不显示（新增时有的）
单身表格的填充主要是在 xxxx_b_fill 方法中，如果遇到单身显示出问题可以去这里纠错。程序出现这种BUG很难用清晰的语言解释清楚并记录下来。。。记录个大体方向以后又遇到了再研究吧。

#上面的SQL有问题，单身中的[料号]本应该带出[品名]和[规格]，
#但是现在查询时没有出现规格，问题应该出现在了填充单身b_fill那一块
#经过检查，上面的sql的确没有写[规格]，因此在下面把它重新覆盖
1
2
3



12. azzi850 给程序授权
13. r.r 执行程序
14. azzi880 将程序挂到 menu
单据别建立流程 ???
1、azzi600 查询 24 系统分类码，在里面新增程序

2、azzi910 修改对应作业的默认单据性质

3、aooi199 里新增单据别

4、aooi200 里添加单据别，注意单据别编号跟aooi199新增的单据别编号一样

注意，对应参照表编号的查看，在 aooi100 中查询当前营运据点，即可看到。

在 aooi100 中查询过后，可知参照表编号为 S01
并且，我们将鼠标放上去，可以看见它是在哪个数据库中进行维护的。

查看 ooef_t 表，发现 ooef004 的确是参照表编号。




双档程序源码分析

type_g_xmzyuc_m 以 m 结尾表示单头的数组；

DEFINE g_xmzyuc_m type_g_xmzyuc_m
并且由程序可知它是个静态数组。
type_g_xmzyuc_d 以 d 结尾表示单身的数组。

DEFINE g_xmzzuc_d DYNAMIC ARRAY OF type_g_xmzzuc_d
由程序可知它是个动态数组。
总结
1、单头部分修改一般在 xxxx_input→DIALOG→INPUT BY NAME .......

开窗功能在 ON ACTION xxxx
校验带值功能在 AFTER FIELD xxxx → 这个其实是过栏位
2、单身部分修改一般在 xxxx_input→DIALOG→INPUT ARRAY ...

开窗功能在 ON ACTION control INFIELD xxxx
3、adzi170 执行SQL，查看数据库中的数据
————————————————
版权声明：本文为CSDN博主「萌宅鹿同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43734095/article/details/113175169
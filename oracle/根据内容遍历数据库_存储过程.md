# ORACLE

```sql
DECLARE
  v_table_name VARCHAR2(100);
  v_count NUMBER;
BEGIN
  FOR tbl IN (SELECT table_name FROM user_tab_columns WHERE column_name = 'mono') LOOP
    v_table_name := tbl.table_name;
    
    -- 检查表名是否为空
    IF v_table_name IS NOT NULL THEN
      -- 检查表是否存在
      BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_table_name || ' WHERE 1 = 0' INTO v_count;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          -- 如果表不存在，则跳过当前循环，继续下一次循环
          CONTINUE;
      END;
      
      -- 检查表中是否存在内容为 "WLS41-23102500201" 的记录
      EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_table_name || ' WHERE mono = ''WLS41-23102500201''' INTO v_count;
      
      -- 如果存在记录，则打印表名和记录数
      IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Table: ' || v_table_name || ', Count: ' || v_count);
      END IF;
    END IF;
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    -- 处理其他异常
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLCODE || ' - ' || SQLERRM);
END;
/
```

```sql
//sqlserver
DECLARE @table_name NVARCHAR(100);
DECLARE @count INT;

DECLARE table_cursor CURSOR FOR
SELECT table_name FROM information_schema.columns WHERE column_name = 'mono';

OPEN table_cursor;

FETCH NEXT FROM table_cursor INTO @table_name;

WHILE @@FETCH_STATUS = 0
BEGIN
    IF @table_name IS NOT NULL
    BEGIN
        BEGIN TRY
            EXEC('SELECT COUNT(*) FROM ' + QUOTENAME(@table_name) + ' WHERE 1 = 0');
            EXEC('SELECT @count = COUNT(*) FROM ' + QUOTENAME(@table_name) + ' WHERE mono = ''WLS41-23102500201''');

            IF @count > 0
                PRINT 'Table: ' + @table_name + ', Count: ' + CAST(@count AS NVARCHAR(10));
        END TRY
        BEGIN CATCH
            -- 处理异常
            PRINT 'Error: ' + CAST(ERROR_NUMBER() AS NVARCHAR(10)) + ' - ' + ERROR_MESSAGE();
        END CATCH
    END

    FETCH NEXT FROM table_cursor INTO @table_name;
END

CLOSE table_cursor;
DEALLOCATE table_cursor;
```

```sql
//mysql
CREATE PROCEDURE check_tables()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE table_name VARCHAR(100);
    DECLARE count INT;

    DECLARE table_cursor CURSOR FOR
    SELECT table_name FROM information_schema.columns WHERE column_name = 'mono';

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN table_cursor;

    read_loop: LOOP
        FETCH table_cursor INTO table_name;

        IF done THEN
            LEAVE read_loop;
        END IF;

        IF table_name IS NOT NULL THEN
            SET @sql = CONCAT('SELECT COUNT(*) FROM `', table_name, '` WHERE 1 = 0');
            PREPARE stmt FROM @sql;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;

            SET @sql = CONCAT('SELECT COUNT(*) INTO @count FROM `', table_name, '` WHERE mono = ''WLS41-23102500201''');
            PREPARE stmt FROM @sql;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;

            IF @count > 0 THEN
                SELECT CONCAT('Table: ', table_name, ', Count: ', @count);
            END IF;
        END IF;
    END LOOP;

    CLOSE table_cursor;
END //

DELIMITER ;

CALL check_tables();
```





好的，以下是修改后的存储过程代码，其中将查询内容作为存储过程的输入参数：

```
sqlCopy CodeCREATE OR REPLACE PROCEDURE check_tables(
  p_mono IN VARCHAR2,
  p_result OUT SYS_REFCURSOR
) AS
  v_table_name VARCHAR2(100);
  v_count NUMBER;
BEGIN
  FOR tbl IN (SELECT table_name FROM user_tab_columns WHERE column_name = p_mono) LOOP
    v_table_name := tbl.table_name;

    -- 检查表名是否为空
    IF v_table_name IS NOT NULL THEN
      -- 检查表是否存在
      BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_table_name || ' WHERE 1 = 0' INTO v_count;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          -- 如果表不存在，则跳过当前循环，继续下一次循环
          CONTINUE;
      END;
      
      -- 检查表中是否存在内容为 p_mono 的记录
      EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_table_name || ' WHERE ' || p_mono || ' = ''' || p_mono || '''' INTO v_count;
      
      -- 如果存在记录，则打印表名和记录数
      IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Table: ' || v_table_name || ', Count: ' || v_count);
      END IF;
    END IF;
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    -- 处理其他异常
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLCODE || ' - ' || SQLERRM);
END;
/
```

在这个修改后的存储过程中，我们添加了一个输入参数 `p_mono`，用于指定要查询的列名。然后，在查询语句中使用该参数进行筛选，找到具有指定列名的表。

此外，我们还将第二个查询内容 `WHERE mono = ''WLS41-23102500201'''` 修改为动态构建查询语句的方式，使用输入参数 `p_mono` 和 `p_mono` 的值来生成查询条件。

要调用这个修改后的存储过程并获取结果，可以使用以下示例代码：

```
sqlCopy CodeDECLARE
  v_result SYS_REFCURSOR;
  v_table_name VARCHAR2(100);
  v_count NUMBER;
BEGIN
  check_tables('mono', v_result);
  
  LOOP
    FETCH v_result INTO v_table_name, v_count;
    EXIT WHEN v_result%NOTFOUND;
    
    DBMS_OUTPUT.PUT_LINE('Table: ' || v_table_name || ', Count: ' || v_count);
  END LOOP;
  
  CLOSE v_result;
END;
/
```

在这个示例中，我们调用存储过程 `check_tables` 并传入参数 `'mono'` 和输出参数 `v_result`。然后，使用循环和 `FETCH` 语句从结果集中逐行读取数据，并打印出表名和记录数。

希望这次的修改满足你的需求。如果还有其他问题，请随时提问。